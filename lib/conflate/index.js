const os = require('os');
const fs = require('fs');
const turf = require('@turf/turf');
const path = require('path');
const readline = require('readline');
const CP = require('child_process');
const Queue = require('d3-queue').queue;
const _ = require('lodash');
const pgcopy = require('pg-copy-streams').from;

const CPUS = os.cpus().length;

const tokenize = require('../util/tokenize');
const tokens = require('@mapbox/geocoder-abbreviations');

/**
 * @class Index
 */
class Index {
    constructor(pool) {
        this.pool = pool;
    }

    /**
     * Initialize an empty conflate database with required tables
     * @param {Function} cb Callback in (err, res)
     * @return {Function} cb
     */
    init(cb) {
        this.pool.connect((err, client, release) => {
            if (err) return cb(err);

            client.query(`
                ABORT;
                BEGIN;

                CREATE EXTENSION IF NOT EXISTS POSTGIS;

                DROP TABLE IF EXISTS persistent;
                CREATE TABLE persistent (id BIGINT, name JSONB, number TEXT, props JSONB, lon TEXT, lat TEXT, geom GEOMETRY(POINT, 4326));

                COMMIT;
            `, (err, res) => {
                client.release();
                return cb(err);
            });
        });
    }

    /**
     * Index/bucket a stream of persistent addresses
     *
     * @param {string} file     of geojson Features to be indexed by `street` property
     * @param {Object} opts     optional arguments
     *                          opts.tokens - JSON Object in the form of a token replacement file. See ./lib/tokens/ for examples
     *                          opts.map    - JS module to filter/convert input into pt2itp accepted format
     *                          opts.error  - File to write invalid features to
     * @param {Function} cb     callback funtion
     * @return {Function}       in the form fxn(err)
    */
    copy(file, opts = {}, cb) {
        let self = this;

        let cpu_spawn = Math.floor(CPUS / 2);
        let nursery = [];

        let ready = 0;

        while (cpu_spawn--) {
            let child = CP.fork(path.resolve(__dirname, './copy'), {
                stdio: ['pipe', 'pipe', 'pipe', 'ipc']
            });

            let psv = `${os.tmpdir()}/persistent-${nursery.length}-${(new Date).getTime()}.psv`;

            let id = nursery.push({
                active: true,
                output: psv,
                child: child
            }) - 1;

            if (opts.error) child.stderr.pipe(opts.error);

            child.stdin.on('error', epipe);
            child.stdout.on('error', epipe);
            child.stderr.on('error', epipe);

            child.send({
                id: id,
                read: path.resolve(__dirname, '..', file),
                type: 'persistent',
                tokens: opts.tokens,
                output: psv,
                total: Math.floor(CPUS / 2),
                error: opts.error ? true : false,
                map: opts.map,
                context: opts.context
            });

            child.on('error', cb);

            child.on('message', (message) => {
                ready++;

                console.error(`ok - persistent child finished`);

                if (ready >= Math.floor(CPUS / 2)) {
                    copyRes();
                }
            });
        }

        /**
         * Handle pipe errors in a standard format
         * @param {Error} err
         * @return {Function} Parent level callback
         */
        function epipe(err) {
            console.error('not ok - epipe error');
            return cb(err);
        }

        /**
         * Copy PSV file generated by child processes into database
         */
        function copyRes() {
            console.error(`ok - standardized address input data`)
            console.error(`ok - importing address data`);

            const addrQ = new Queue();

            for (let child of nursery) {
                addrQ.defer((output, done) => {
                    self.pool.connect((err, client, pgdone) => {
                        if (err) return done(err);

                        const cpStream = client.query(pgcopy(`
                            COPY persistent (id, name, number, props, lon, lat)
                                FROM STDIN
                                WITH
                                    CSV
                                    DELIMITER '|'
                                    QUOTE E'\b'
                                    NULL AS ''
                        `));
                        const fsStream = fs.createReadStream(output);

                        fsStream.on('error', done);
                        cpStream.on('error', done);
                        cpStream.on('end', (err, res) => {
                            if (err) return done(err);

                            pgdone();

                            fs.unlink(output, (err) => {
                                return done(err);
                            });
                        });

                        fsStream.pipe(cpStream);
                    });
                }, child.output);
            }

            addrQ.awaitAll((err, res) => {
                if (err) return cb(err);

                for (let child of nursery) {
                    child.child.kill();
                }

                return cb();
            });
        }
    }


    /**
     * Add indexes to persistent table
     * @param {Function} cb Callback in (err, res)
     * @return {Function} cb
     */
    optimize(cb) {
        const self = this;

        this.pool.query(`
            BEGIN;

            UPDATE persistent SET geom = ST_SetSRID(ST_MakePoint(substring(lon from 1 for 10)::NUMERIC, substring(lat from 1 for 10)::NUMERIC, encoded), 4326);

            ALTER TABLE address DROP COLUMN lat;
            ALTER TABLE address DROP COLUMN lon;

            CREATE INDEX persistent_idx ON persistent (id);
            CREATE INDEX persistent_gix ON persistent USING GIST (geom);
            CLUSTER persistent USING persistent_idx;
            ANALYZE address;

            COMMIT;
        `, cb);
    }
}

module.exports = Index;
